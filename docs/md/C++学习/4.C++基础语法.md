# C++基础语法

## 基本数据类型
* 布尔类型：`bool`（布尔值，`true` 或 `false`）
* 整数类型：`int`（整数）
* 浮点类型：`float`（单精度浮点数），`double`（双精度浮点数）
* 字符类型：`char`（字符）


> 类型所占用的字节数/位宽可通过内置函数 `sizeof()` 查看。
`C++`的标准并没有规定每种类型占多少位，只是说 `sizeof(long) >= sizeof(int) >= sizeof(short)`，
所以具体的字节大小由编译器位宽决定。 `1个字节 = 8 位`, 位宽决定了类型范围, 可通过`numeric_limits`进行查询。

基本类型可以使用一个或多个`修饰符类型`进行修饰：
* `signed`: 有符号类型
* `unsigned`: 无符号类型
* `short`: 短类型
* `long`: 长类型
> 默认情况下，int、short、long都是带符号的，即 signed。

```C++
#include<iostream>
#include <limits>
using namespace std;
int main() {
    cout << "unsigned: \t" << "所占字节数：" << sizeof(unsigned);
    cout << "\t最大值：\t" << (numeric_limits<unsigned>::max)();
    cout << "\t最小值：" << (numeric_limits<unsigned>::min)() << endl;

    cout << "long double: \t" << "所占字节数：" << sizeof(long double);
    cout << "\t最大值：\t" << (numeric_limits<long double>::max)();
    cout << "\t最小值：" << (numeric_limits<long double>::min)() << endl;

    cout << "wchar_t: \t" << "所占字节数：" << sizeof(wchar_t);
    cout << "\t最大值：\t" << (numeric_limits<wchar_t>::max)();
    cout << "\t\t最小值：" << (numeric_limits<wchar_t>::min)() << endl;
}

输出：
unsigned: 	所占字节数：4	最大值：	4294967295	最小值：0
long double: 	所占字节数：16	最大值：	1.18973e+4932	最小值：3.3621e-4932
wchar_t: 	所占字节数：2	最大值：	65535		最小值：0
```

### 其他类型: 
* `enum`枚举类型: 用于定义一组命名的常量
* `typedef`别名: 为一个已有的类型取一个新的名字
* `struct`结构体类型：由多个不同类型的数据组成的集合。
* `class`类类型：由多个不同类型的数据和函数组成的集合
* `string`字符串：用于存储文本。
* `*`指针类型：指向某个地址的指针变量。
* `&`引用类型：用于别名，可以用作变量的别名。。
* 数组：一组相同类型的数据组成的集合。
* 其他：`wchar_t`宽字符型、`void`无类型、`union`联合

## 运算符
* 算术运算符: `+`、`-`、`*`、`/`、`%`、`++`、`--`
* 关系运算符: `==`、`!=`、`>`、`<`、`>=`、`<=`
* 逻辑运算符: `&&`、`||`、`!`
* 位运算符: `&`、`|`、`^（异或）`、`~（取反）`、`<<`、`>>`
* 赋值运算符: `=`、`+=`、`-=`、`*=`、`/=`、`%=`、`<<=`、`>>=`、`&=`、`|=`、`^=`
* 杂项运算符:
  
  |运算符 |描述 |
  |---|---|
  |`sizeof` |	sizeof 运算符返回变量的大小。例如，sizeof(a) 将返回 4，其中 a 是整数。 |
  |`Condition ? X : Y` | 	条件运算符。如果 Condition 为真 ? 则值为 X : 否则值为 Y。|
  |`,`|逗号运算符会顺序执行一系列运算。整个逗号表达式的值是以逗号分隔的列表中的最后一个表达式的值。 |
  |`.`和 `->`|成员运算符用于引用类、结构和共用体的成员。|
  |`Cast`|	强制转换运算符把一种数据类型转换为另一种数据类型。例如，int(2.2000) 将返回 2。 |
  |`&`|指针运算符 & 返回变量的地址。例如 &a; 将给出变量的实际地址。 |
  |`*`|指针运算符 * 指向一个变量。例如，*var; 将指向变量 var。 |

### 运算符优先级
`括号和作用域运算符` > `其他一元运算符` > `算数运算符` > `关系运算符` > `位运算符` > `逻辑运算符` > `赋值运算符`
> 注意：位运算符是比较靠后的，使用时容易出错。如果不清楚优先级关系，应使用括号保证计算先后顺序。

按运算符优先级从高到低:
* 先算右一后左一，①
> ①先算右面的一元运算符，后算左面的。
* 乘除加减移位比。②
> ②乘除代表*/%，加减就是+和-，移位就是<<和>>，比就是比较运算符，注意比较运算符先算<、>、<=和>=这4个含不等号的，后算==和!=这两个。
* 与异或或位逻辑，③
> ③先算按位逻辑运算符，再算普通的逻辑运算符；按位逻辑运算符的顺序是&^|，逻辑运算符先算&&再算||，只是少了逻辑异或。
* 三目赋值逗号稀。④
>  ④先算三目运算符，再算赋值运算符，逗号运算符的优先级最低，所以说它“稀”。


## 逻辑控制语句
编程语言中用于控制程序流程的语句。包括条件语句,循环语句和跳转语句，语句之间可以嵌套使用。

### 条件语句
C 语言把任何非零和非空的值假定为 true，把零或 null 假定为 false。
- `if`语句:
```C++
if(布尔表达式) {
  // 如果布尔表达式为真将执行的语句
}
```
- `if...else`语句:
```C++
if(布尔表达式) {
   // 如果布尔表达式为真将执行的语句
} else {
   // 如果布尔表达式为假将执行的语句
}
```
>  条件运算符 `? :`，可以用来替代 `if...else` 语句;
- `if...else if...else `语句:
```C++
if(布尔表达式 1) {
   // 当布尔表达式 1 为真时执行
} else if(布尔表达式 2) {
   // 当布尔表达式 2 为真时执行
} else if(布尔表达式 3) {
   // 当布尔表达式 3 为真时执行
} else {
   // 当上面条件都不为真时执行
}
```
- `switch`语句: 用来根据不同的条件执行不同的代码块
```C++
switch(表达式或变量) {
   case 常量表达式:
      语句块;
      break; // 可选的，用于退出 switch 语句
   case 常量表达式:
      语句块;
      break; // 可选的，用于退出 switch 语句
   // 可以有任意数量的 case 语句
   default: // 可选的
      语句块;
}
```
> `表达式或变量`会与各个`case的常量表达式`进行比较。如果和某个`case的常量表达式`的值相等，则执行该`case后面的语句块`，
> 直到遇到`break`语句或`switch`语句结束; 如果值与所有`case的常量表达式`的值都不匹配，则执行`default语句后面的语句块`。

### 循环语句
- while循环：只要条件为真，就重复执行代码块。
```C++
while(条件) {
   语句块;
}
```  
- do-while循环：先执行一次代码块，然后只要条件为真，就重复执行代码块。
```C++
do {
   语句块;
} while(条件);
```  
- for循环：在一定次数内重复执行代码块，每次执行前都会更新循环计数器的值。
  - `初始化`会首先被执行，且只会执行一次。可以为空，但是需要有分号出现；
  - 判断`条件`如果为真，则执行循环主体。
  - 执行完 `for 循环主体`后，控制流会跳回上面的 `增加量` 语句, 该语句允许您更新循环控制变量。可以为空，但是需要有分号出现；
```C++
for (初始化; 条件; 增加量) {
   语句块;
}
```

### 跳转语句
- `break` 语句: 终止 `循环` 或 `switch` 语句，程序流将继续执行紧接着 `循环` 或 `switch` 的下一条语句。
- `continue` 语句: 使`循环跳过`主体的剩余部分，立即重新开始测试条件。
- `goto` 语句: 跳转到被标记的语句处继续执行。但是不建议在程序中使用 `goto` 语句。

## 函数
函数是一组一起执行一个任务的语句。

### 函数定义
- 函数由一个函数头和一个函数主体组成。
  - 返回类型：一个函数可以返回一个值。若不行返回值，可以用 `void`。
  - 函数名称：这是函数的实际名称。函数名和参数列表一起构成了函数签名。
  - 参数：参数就像是占位符。当函数被调用时，您向参数传递一个值，这个值被称为实际参数。参数列表包括函数参数的类型、顺序、数量。参数是可选的。
  - 函数主体：函数主体包含一组定义函数执行任务的语句。
```C++
返回类型 函数名( 参数列表 ) {
  函数主体;
}
```
### 函数声明
- 函数声明会告诉编译器函数名称及如何调用函数。函数的实际主体可以单独定义。
  - 函数声明中，参数的名称并不重要，只有参数的类型是必需的，
  - 在一个源文件中定义函数且在另一个文件中调用函数时，函数声明是必需的。
```C++
返回类型 函数名( 参数列表 );
```

### 函数参数
函数的参数也叫做形式参数；就像函数内的其他局部变量，在进入函数时被创建，退出函数时被销毁。

调用函数时，有三种向函数传递参数的方式：
- 传值调用：把`参数的实际值`复制给形式参数。函数内形式参数的修改`不会影响`实际参数
- 指针调用：把`参数的地址` 复制给形式参数。函数内形式参数的修改`会影响`实际参数
- 引用调用：把`参数的引用` 复制给形式参数。函数内形式参数的修改`会影响`实际参数
> 默认情况下，C++ 使用`传值调用`来传递参数。

#### 参数的默认值
定义一个函数，可以为参数列表中后边的每一个参数指定默认值。
当调用函数时，如果未传递参数的值，则会使用默认值，如果指定了值，则会忽略默认值，使用传递的值。

### Lambda 函数与表达式
匿名函数称为 `Lambda` 函数(也叫 `Lambda` 表达式);

`Lambda` 表达式把函数看作对象。
`Lambda` 表达式可以像对象一样使用，比如可以将它们赋给变量和作为参数传递，还可以像函数一样对其求值。
`Lambda` 表达式本质上与函数声明非常类似。
```
[捕获](参数)->返回类型{返回主体}
```
> 如果 lambda 函数没有传回值（例如 void），其返回类型可被完全忽略。

Lambda表达式内可以访问当前作用域的变量，这是`Lambda`表达式的`闭包（Closure）行为`
```C++
[]      // 沒有定义任何变量。使用未定义变量会引发错误。
[x, &y] // x以传值方式传入（默认），y以引用方式传入。
[&]     // 任何被使用到的外部变量都隐式地以引用方式加以引用。
[=]     // 任何被使用到的外部变量都隐式地以传值方式加以引用。
[&, x]  // x显式地以传值方式加以引用。其余变量以引用方式加以引用。
[=, &z] // z显式地以引用方式加以引用。其余变量以传值方式加以引用。
```
> 对于[=]或[&]的形式，lambda 表达式可以直接使用 this 指针。但是，对于[]的形式，如果要使用 this 指针，必须显式传入：

## 命名空间
作为附加信息来区分不同库中相同名称的函数、类、变量等。使用了命名空间即定义了上下文。本质上，命名空间就是定义了一个范围。

### 定义命名空间
```C++
namespace 命名空间的名称 {
   // 代码声明
}
```
为了调用带有命名空间的函数或变量，需要在前面加上命名空间的名称。
```C++
命名空间的名称::code;  // code 可以是变量或函数
```

### using 指令
使用 `using namespace` 指令，告诉编译器，后续的代码将使用指定的命名空间中的名称。
这样在使用命名空间时就可以不用在前面加上命名空间的名称。

`using` 指令也可以用来指定命名空间中的特定项目。例如，如果您只打算使用 std 命名空间中的 cout 部分，您可以使用如下的语句：
```C++
using std::cout;
```

### 嵌套的命名空间
可以在一个命名空间中定义另一个命名空间
```C++
namespace 命名空间的名称1 {
   // 代码声明
   namespace 命名空间的名称2 {
      // 代码声明
   }
}
```
通过使用 `::`运算符来访问嵌套的命名空间中的成员
```C++
// 访问 namespace_name2 中的成员
using namespace 命名空间的名称1::命名空间的名称2;
 
// 访问 namespace_name1 中的成员
using namespace 命名空间的名称1;
```

## 宏定义和常量的区别
- 类型和安全检查不同
  - 宏定义是字符替换，没有数据类型的区别，同时这种替换没有类型安全检查，可能产生边际效应等错误；
  - const常量是常量的声明，有类型区别，需要在编译阶段进行类型检查

- 编译器处理不同
  - 宏定义是一个"编译时"概念，在预处理阶段展开，不能对宏定义进行调试，生命周期结束与编译时期；
  - const常量是一个"运行时"概念，在程序运行使用，类似于一个只读行数据

- 存储方式不同
  - 宏定义是直接替换，不会分配内存，存储于程序的代码段中；
  - const常量需要进行内存分配，存储于程序的数据段中

- 定义域不同
```C++
void f1 () {
  #define N 12
  const int n 12;
}
void f2 () {
  cout<<N <<endl; //正确，N已经定义过，不受定义域限制
  cout<<n <<endl; //错误，n定义域只在f1函数中
}
```

- 定义后能否取消
  - 宏定义可以通过#undef来使之前的宏定义失效
  - const常量定义后将在定义域内永久有效
```C++
void f1() {
  #define N 12
  const int n = 12;
  
  #undef N //取消宏定义后，即使在f1函数中，N也无效了
  #define N 21//取消后可以重新定义
}
```

- 是否可以做函数参数
  - 宏定义不能作为参数传递给函数
  - const常量可以在函数的参数列表中出现


## 类型转换
C++ 中有四种类型转换：静态转换、动态转换、常量转换和重新解释转换。

|转换|适配范围|注意点|
|---|---|---|
|静态转换 `Static Cast`| 比较类型相似的对象之间转换|不做运行时类型检查，可能导致运行时错误|
|动态转换 `Dynamic Cast`| 基类指针或引用转派生类指针或引用|运行时进行类型检查，不能转换则返回空指针或引发异常|
|常量转换 `Const Cast`| `const`类型对象转`非const`类型对象|只转换掉`const`属性，不改变类型|
|重新解释转换 `Reinterpret Cast`|不同数据类型之间转换|不进行任何类型检查，可能会导致未定义的行为。|

## 指针
### 内存地址
每一个变量都有一个内存位置，每一个内存位置都定义了可使用连字号（&）运算符访问的地址，它表示了在内存中的一个地址。

### 指针定义
- 指针是一个变量，其值为另一个变量的地址，即，内存位置的直接地址。
- 指针的值的实际数据类型，不管是整型、浮点型、字符型，还是其他的数据类型，都是一样的，都是一个代表内存地址的长的十六进制数
> C++ 不支持在函数外返回局部变量的地址，除非定义局部变量为 `static变量`。


## 动态内存
C++ 程序中的内存分为两个部分：
- 堆：程序中未使用的内存，在程序运行时可用于动态分配内存。
- 栈：在函数内部声明的所有变量都将占用栈内存。
### new 和 delete 运算符
- new: 为给定类型的变量在运行时分配堆内的内存，这会返回所分配的空间地址
- delete: 删除之前由 new 运算符分配的内存


