# C++面向对象特性
C++ 完全支持面向对象的程序设计，包括面向对象开发的四大特性：
- 封装（Encapsulation）：封装是将数据和方法组合在一起，对外部隐藏实现细节，只公开对外提供的接口。这样可以提高安全性、可靠性和灵活性。
- 继承（Inheritance）：继承是从已有类中派生出新类，新类具有已有类的属性和方法，并且可以扩展或修改这些属性和方法。这样可以提高代码的复用性和可扩展性。
- 多态（Polymorphism）：多态是指同一种操作作用于不同的对象，可以有不同的解释和实现。它可以通过接口或继承实现，可以提高代码的灵活性和可读性。
- 抽象（Abstraction）：抽象是从具体的实例中提取共同的特征，形成抽象类或接口，以便于代码的复用和扩展。抽象类和接口可以让程序员专注于高层次的设计和业务逻辑，而不必关注底层的实现细节。

## 类与对象
### 类与对象的概念
- 对象: 是现实中的对象在程序中的模拟; 对象是类的某一特定实体。
- 类: 是同一类对象的抽象; 一种用户自定义的类型，包含函数与数据的特殊结构体。

#### 类的定义
![](https://www.runoob.com/wp-content/uploads/2015/05/cpp-classes-objects-2020-12-10-11.png)

### 类成员访问控制
- 访问权限类型分为公有类型`public`、保护类型`protected`、私有类型`private`
- 成员默认的访问控制权限为`private`
- 友元函数或友元类可访问类的保护成员或私有成员

### 继承方式
`class` 默认是 `private` 继承; `struct` 默认 `public` 继承：

|继承方式|基类的public成员|基类的protected成员|基类的private成员|变化概括|
|---|---|---|---|---|
|public继承 |仍是public成员 |仍是protected成员 |不可见 |基类的非私有成员在子类的访问属性不变|
|protected继承|	变为protected成员	|变为protected成员|	不可见|	基类的非私有成员都为子类的保护成员|
|private继承|	变为private成员	|变为private成员	|不可见	|基类中的非私有成员都称为子类的私有成员|

## 类的构造与析构
`类的构造函数` 在每次创建类的新对象时执行。
- 构造函数的`名称与类的名称是完全相同的`，并且不会返回任何类型，也不会返回 void。
- 默认的构造函数没有任何参数，但如果需要，构造函数也可以带有参数。创建对象时就会给对象赋初始值,用于为某些成员变量设置初始值。
    - 可以使用初始化列表来初始化字段。

`类的析构函数` 在每次删除所创建的对象时执行。
- 析构函数的`名称与类的名称是完全相同的，只是在前面加了个波浪号（~）作为前缀`，它不会返回任何值，也`不能带有任何参数`。
- 析构函数有助于在跳出程序（比如关闭文件、释放内存等）前`释放资源`

> 一个类内可以有多个构造函数，可以是一般类型的，也可以是带参数的，相当于重载构造函数，但是析构函数只能有一个。 如下例：

```C++
class Matrix
{
public:
    Matrix(int row, int col);          //普通构造函数
    Matrix(const Matrix& matrix);      //拷贝构造函数
    Matrix();                          //构造空矩阵的构造函数
    void print(void);
    ~Matrix();
};
```

## 其他特性

### 重载运算符和重载函数
在同一作用域中的某个`函数`和`运算符`指定多个定义，分别称为`函数重载`和`运算符重载`

#### 函数重载
在同一个作用域内，可以声明几个功能类似的同名函数，但是这些同名函数的`形式参数`（指参数的个数、类型或者顺序）必须不同

#### 运算符重载
可以重定义或重载大部分 C++ 内置的运算符。

不可重载的运算符列表：
- .：成员访问运算符
- .*, ->*：成员指针访问运算符
- ::：域运算符
- sizeof：长度运算符
- ?:：条件运算符
- \#： 预处理符号

## 继承
继承允许依据另一个类来定义一个类，已有的类称为基类，新建的类称为派生类。
C++ 类可以从多个类继承成员，语法如下：
```C++
class <派生类名>:<继承方式1><基类名1>,<继承方式2><基类名2>,… {
    <派生类类体>
};

```

### 继承类型
- 公有继承（public）：当一个类派生自公有基类时，基类的公有成员也是派生类的公有成员，基类的保护成员也是派生类的保护成员，基类的私有成员不能直接被派生类访问，但是可以通过调用基类的公有和保护成员来访问。
- 保护继承（protected）： 当一个类派生自保护基类时，基类的公有和保护成员将成为派生类的保护成员。
- 私有继承（private）：当一个类派生自私有基类时，基类的公有和保护成员将成为派生类的私有成员。

## 多态
`多态`按字面的意思就是多种形态。当类之间存在层次结构，并且类之间是通过继承关联时，就会用到`多态`。
形成多态必须具备三个条件：
- 必须存在继承关系；
- 继承关系必须有同名虚函数（其中虚函数是在基类中使用关键字Virtual声明的函数，在派生类中重新定义基类中定义的虚函数时，会告诉编译器不要静态链接到该函数）；
- 存在基类类型的指针或者引用，通过该指针或引用调用虚函数

### 虚函数
- 定义一个函数为虚函数，不代表函数为不被实现的函数。
- 定义他为虚函数是为了允许用基类的指针来调用子类的这个函数。
- 定义一个函数为纯虚函数，才代表函数没有被实现。
- 定义纯虚函数是为了实现一个接口，起到一个规范的作用，规范继承这个类的程序员必须实现这个函数。

 
## RTTI与抽象类
设计抽象类（通常称为 ABC）的目的，是为了给其他类提供一个可以继承的适当的基类。
- 抽象类不能被用于实例化对象，它只能作为接口使用。

抽象类是指含有纯虚函数（Pure Virtual Function）的类。纯虚函数是指在函数声明中使用“=0”来表示该函数没有实现，需要在派生类中实现。抽象类不能被实例化，只能被用作基类，派生类需要实现纯虚函数才能被实例化。

RTTI（Run-Time Type Information，运行时类型信息）是C++语言的一个特性，它允许程序在运行时获取一个对象的类型信息。通过RTTI，程序可以判断一个对象是否属于某个特定的类，或者是该类的派生类。
